"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports._parseTimeSeries = exports._parse = exports._fetch = exports.fetchWeatherData = exports.RetryableWeatherDataError = void 0;
const flatbuffers_1 = require("flatbuffers");
const weather_api_response_1 = require("@openmeteo/sdk/weather-api-response");
class RetryableWeatherDataError extends Error {
    constructor(msg, cause) {
        super(msg, { cause });
    }
}
exports.RetryableWeatherDataError = RetryableWeatherDataError;
const fetchWeatherData = async (params, api = 'https://api.open-meteo.com/v1/forecast') => {
    return (0, exports._parse)(await (0, exports._fetch)(params, api), params);
};
exports.fetchWeatherData = fetchWeatherData;
const _fetch = async (params, api) => {
    const searchParams = new URLSearchParams(Object.entries(params).map(([k, v]) => [k, `${v}`]));
    searchParams.set('format', 'flatbuffers');
    const url = `${api}?${searchParams}`;
    let response;
    try {
        response = await fetch(url);
    }
    catch (err) {
        throw new RetryableWeatherDataError('fetch error', err);
    }
    const { status } = response;
    if (status >= 400 && status < 500) {
        const json = await response.json();
        const reason = json && typeof json === 'object' && 'reason' in json ? json.reason : 'unknown';
        throw Error(`${reason}`);
    }
    if (status !== 200)
        throw new RetryableWeatherDataError(`received unexpected status ${status}`);
    return new Uint8Array(await response.arrayBuffer());
};
exports._fetch = _fetch;
const _parse = (buffer, params) => {
    const bb = new flatbuffers_1.ByteBuffer(buffer);
    const r = weather_api_response_1.WeatherApiResponse.getSizePrefixedRootAsWeatherApiResponse(bb);
    const result = {
        latitude: r.latitude(),
        longitude: r.longitude(),
        elevation: r.elevation(),
        utc_offset_seconds: r.utcOffsetSeconds(),
        timezone: r.timezone(),
        timezone_abbreviation: r.timezoneAbbreviation(),
    };
    const hourly = r.hourly();
    if (hourly && params.hourly) {
        result.hourly = (0, exports._parseTimeSeries)(hourly, params.hourly);
    }
    const daily = r.daily();
    if (daily && params.daily) {
        result.daily = (0, exports._parseTimeSeries)(daily, params.daily);
    }
    const current = r.current();
    if (current && params.current) {
        const c = {};
        c.time = Number(current.time());
        params.current.forEach((name, i) => {
            c[name] = current.variables(i)?.value() ?? NaN;
        });
        result.current = c;
    }
    return result;
};
exports._parse = _parse;
const _parseTimeSeries = (ts, params) => {
    const timeStart = Number(ts.time());
    const timeEnd = Number(ts.timeEnd());
    const interval = Number(ts.interval());
    const length = { length: (timeEnd - timeStart) / interval };
    const getTimestamp = (i, j) => Number(ts.variables(i)?.valuesInt64(j));
    const getValue = (i, j) => ts.variables(i)?.values(j) ?? NaN;
    const result = {};
    result.time = Array.from(length, (_, i) => timeStart + i * interval);
    params.forEach((name, i) => {
        const getNumber = ['sunrise', 'sunset'].includes(name) ? getTimestamp : getValue;
        result[name] = Array.from(length, (_, j) => getNumber(i, j));
    });
    return result;
};
exports._parseTimeSeries = _parseTimeSeries;
//# sourceMappingURL=main.js.map